/*
 * JGrapes Event Driven Framework
 * Copyright (C) 2017-2020 Michael N. Lipp
 * 
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Affero General Public License as published by 
 * the Free Software Foundation; either version 3 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */

package org.jgrapes.webcon.base;

import java.beans.ConstructorProperties;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringWriter;
import java.net.URL;
import java.nio.CharBuffer;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.UUID;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;
import java.util.function.Supplier;

import org.jgrapes.core.Channel;
import org.jgrapes.core.Component;
import org.jgrapes.core.Components;
import org.jgrapes.core.Components.Timer;
import org.jgrapes.core.Event;
import org.jgrapes.core.annotation.Handler;
import org.jgrapes.core.annotation.HandlerDefinition.ChannelReplacements;
import org.jgrapes.http.Session;
import org.jgrapes.io.IOSubchannel;
import org.jgrapes.io.events.Closed;
import org.jgrapes.webcon.base.ConsoleComponent.RenderMode;
import org.jgrapes.webcon.base.events.AddComponentRequest;
import org.jgrapes.webcon.base.events.AddComponentType;
import org.jgrapes.webcon.base.events.ComponentResourceRequest;
import org.jgrapes.webcon.base.events.ConsoleReady;
import org.jgrapes.webcon.base.events.DeleteComponent;
import org.jgrapes.webcon.base.events.DeleteComponentRequest;
import org.jgrapes.webcon.base.events.NotifyComponentModel;
import org.jgrapes.webcon.base.events.NotifyPortletView;
import org.jgrapes.webcon.base.events.RenderComponent;
import org.jgrapes.webcon.base.events.RenderComponentRequest;
import org.jgrapes.webcon.base.events.RenderComponentRequestBase;
import org.jgrapes.webcon.base.events.SetLocale;

/**
 * Provides a base class for implementing portlet components.
 * In addition to translating events to invocations of abstract
 * methods, this class manages the state information of a
 * portlet instance.
 * 
 * # Event handling
 * 
 * The following diagrams show the events exchanged between
 * the {@link WebConsole} and a portlet from the portlet's 
 * perspective. If applicable, they also show how the events 
 * are translated by the {@link AbstractComponent} to invocations 
 * of the abstract methods that have to be implemented by the
 * derived class (the portlet component that provides
 * a specific portlet type).
 * 
 * ## ConsoleReady
 * 
 * ![Add portlet type handling](AddPortletTypeHandling.svg)
 * 
 * From the portal page point of view, a portlet consists of
 * CSS and JavaScript that is added to the portal page by
 * {@link AddComponentType} events and HTML that is provided by 
 * {@link RenderComponent} events (see below). These events must 
 * therefore be generated by a portlet component. With respect to
 * the firing of the initial {@link AddComponentType}, 
 * the {@link AbstractComponent} does not provide any support. The
 * handler for the {@link ConsoleReady} must be implemented by
 * the derived class itself.
 * 
 * ## AddComponentRequest
 * 
 * ![Add portlet handling](AddPortletHandling.svg)
 * 
 * The {@link AddComponentRequest} indicates that a new portlet
 * instance of a given type should be added to the page. The
 * {@link AbstractComponent} checks the type requested, and if
 * it matches, invokes {@link #doAddPortlet doAddPortlet}. The
 * derived class generates a new unique portlet id (optionally 
 * using {@link #generatePortletId generatePortletId}) 
 * and a state (model) for the instance. The derived class 
 * calls {@link #putInSession putInSession} to make the
 * state known to the {@link AbstractComponent}. Eventually,
 * it fires the {@link RenderComponent} event and returns the
 * new portlet id. The {@link RenderComponent} event delivers
 * the HTML that represents the portlet on the page to the portal
 * session. The portlet state may be used to generate HTML that represents
 * the state. Alternatively, state independent HTML may be delivered
 * followed by a {@link NotifyPortletView} event that updates
 * the HTML using JavaScript in the portal page.
 * 
 * ## RenderComponent
 * 
 * ![Render portlet handling](RenderPortletHandling.svg)
 * 
 * A {@link RenderComponent} event indicates that the portal page
 * needs the HTML for displaying a portlet. This may be cause
 * by e.g. a refresh or by requesting a full page view from
 * the preview.
 * 
 * Upon receiving such an event, the {@link AbstractComponent}
 * checks if it has state information for the portlet id
 * requested. If so, it invokes 
 * {@link #doRenderPortlet doRenderPortlet}
 * with the state information. This method has to fire
 * the {@link RenderComponent} event that delivers the HTML.
 * 
 * ## DeleteComponentRequest
 * 
 * ![Delete portlet handling](DeletePortletHandling.svg)
 * 
 * When the {@link AbstractComponent} receives a {@link DeleteComponentRequest},
 * it checks if state information for the portlet id exists. If so,
 * it deletes the state information from the session and
 * invokes 
 * {@link #doDeletePortlet(DeleteComponentRequest, ConsoleSession, String, S)}
 * with the state information. This method fires the {@link DeleteComponent}
 * event that confirms the deletion of the portlet.
 * 
 * ## NotifyComponentModel
 * 
 * ![Notify portlet model handling](NotifyPortletModelHandling.svg)
 * 
 * If the portlet display includes input elements, actions on these
 * elements may result in {@link NotifyComponentModel} events from
 * the portal page to the portal. When the {@link AbstractComponent}
 * receives such events, it checks if state information for the 
 * portlet id exists. If so, it invokes 
 * {@link #doNotifyPortletModel doNotifyPortletModel} with the
 * retrieved information. The portal component usually responds with
 * a {@link NotifyPortletView} event. However, it can also
 * re-render the complete portelt display.
 * 
 * Support for unsolicited updates
 * -------------------------------
 * 
 * In addition, the class provides support for tracking the 
 * relationship between {@link ConsoleSession}s and the ids 
 * of portlets displayed in the portal session and support for
 * unsolicited updates.
 *
 * @param <S> the type of the portlet state information
 * 
 * @startuml AddPortletTypeHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> ConsoleComponent: ConsoleReady
 * deactivate WebConsole
 * activate ConsoleComponent
 * ConsoleComponent -> WebConsole: AddComponentType 
 * deactivate ConsoleComponent
 * activate WebConsole
 * deactivate WebConsole
 * @enduml 
 * @startuml AddPortletHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> ConsoleComponent: AddComponentRequest
 * deactivate WebConsole
 * activate ConsoleComponent
 * ConsoleComponent -> ConsoleComponent: doAddPortlet
 * activate ConsoleComponent
 * opt
 * 	   ConsoleComponent -> ConsoleComponent: generatePortletId
 * end opt
 * ConsoleComponent -> ConsoleComponent: putInSession
 * ConsoleComponent -> WebConsole: RenderComponent
 * opt 
 *     ConsoleComponent -> WebConsole: NotifyPortletView
 * end opt 
 * deactivate ConsoleComponent
 * deactivate ConsoleComponent
 * activate WebConsole
 * deactivate WebConsole
 * @enduml 
 * @startuml RenderPortletHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> ConsoleComponent: RenderComponent
 * deactivate WebConsole
 * activate ConsoleComponent
 * ConsoleComponent -> ConsoleComponent: doRenderPortlet
 * activate ConsoleComponent
 * ConsoleComponent -> WebConsole: RenderComponent 
 * opt 
 *     ConsoleComponent -> WebConsole: NotifyPortletView
 * end opt 
 * deactivate ConsoleComponent
 * deactivate ConsoleComponent
 * activate WebConsole
 * deactivate WebConsole
 * @enduml 
 * @startuml NotifyPortletModelHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> ConsoleComponent: NotifyComponentModel
 * deactivate WebConsole
 * activate ConsoleComponent
 * ConsoleComponent -> ConsoleComponent: doNotifyPortletModel
 * activate ConsoleComponent
 * opt
 *     ConsoleComponent -> WebConsole: RenderComponent
 * end opt 
 * opt 
 *     ConsoleComponent -> WebConsole: NotifyPortletView
 * end opt 
 * deactivate ConsoleComponent
 * deactivate ConsoleComponent
 * activate WebConsole
 * deactivate WebConsole
 * @enduml 
 * @startuml DeletePortletHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> ConsoleComponent: DeleteComponentRequest
 * deactivate WebConsole
 * activate ConsoleComponent
 * ConsoleComponent -> ConsoleComponent: doDeletePortlet
 * activate ConsoleComponent
 * ConsoleComponent -> WebConsole: DeleteComponent 
 * deactivate ConsoleComponent
 * deactivate ConsoleComponent
 * activate WebConsole
 * deactivate WebConsole
 * @enduml 
 */
@SuppressWarnings({ "PMD.TooManyMethods",
    "PMD.EmptyMethodInAbstractClassShouldBeAbstract" })
public abstract class AbstractComponent<S extends Serializable>
        extends Component {

    private Map<ConsoleSession, Set<String>> portletIdsByPortalSession;
    private Duration refreshInterval;
    private Supplier<Event<?>> refreshEventSupplier;
    private Timer refreshTimer;
    private Map<Locale, ResourceBundle> l10nBundles = new HashMap<>();

    /**
     * Creates a new component that listens for new events
     * on the given channel.
     * 
     * @param channel the channel to listen on
     */
    public AbstractComponent(Channel channel) {
        this(channel, null);
    }

    /**
     * Like {@link #AbstractComponent(Channel)}, but supports
     * the specification of channel replacements.
     *
     * @param channel the channel to listen on
     * @param channelReplacements the channel replacements (see
     * {@link Component})
     */
    public AbstractComponent(Channel channel,
            ChannelReplacements channelReplacements) {
        super(channel, channelReplacements);
        portletIdsByPortalSession
            = Collections.synchronizedMap(new WeakHashMap<>());
    }

    /**
     * If set to a value different from `null` causes an event
     * from the given supplier to be fired on all tracked portal
     * sessions periodically.
     *
     * @param interval the refresh interval
     * @param supplier the supplier
     * @return the portlet for easy chaining
     */
    public AbstractComponent<S> setPeriodicRefresh(
            Duration interval, Supplier<Event<?>> supplier) {
        refreshInterval = interval;
        refreshEventSupplier = supplier;
        if (refreshTimer != null) {
            refreshTimer.cancel();
            refreshTimer = null;
        }
        updateRefresh();
        return this;
    }

    private void updateRefresh() {
        if (refreshInterval == null || portletIdsByPortalSession().isEmpty()) {
            // At least one of the prerequisites is missing, terminate
            if (refreshTimer != null) {
                refreshTimer.cancel();
                refreshTimer = null;
            }
            return;
        }
        if (refreshTimer != null) {
            // Already running.
            return;
        }
        refreshTimer = Components.schedule(tmr -> {
            tmr.reschedule(tmr.scheduledFor().plus(refreshInterval));
            fire(refreshEventSupplier.get(), trackedSessions());
        }, Instant.now().plus(refreshInterval));
    }

    /**
     * Returns the portlet type. The default implementation
     * returns the class' name.
     * 
     * @return the type
     */
    protected String type() {
        return getClass().getName();
    }

    /**
     * A default handler for resource requests. Checks that the request
     * is directed at this portlet, and calls {@link #doGetResource}.
     * 
     * @param event the resource request event
     * @param channel the channel that the request was recived on
     */
    @Handler
    public final void onResourceRequest(
            ComponentResourceRequest event, IOSubchannel channel) {
        // For me?
        if (!event.portletClass().equals(type())) {
            return;
        }
        doGetResource(event, channel);
    }

    /**
     * The default implementation searches for a file with the 
     * requested resource URI in the portlet's class path and sets 
     * its {@link URL} as result if found.
     * 
     * @param event the event. The result will be set to
     * `true` on success
     * @param channel the channel
     */
    protected void doGetResource(ComponentResourceRequest event,
            IOSubchannel channel) {
        URL resourceUrl = this.getClass().getResource(
            event.resourceUri().getPath());
        if (resourceUrl == null) {
            return;
        }
        event.setResult(new ResourceByUrl(event, resourceUrl));
        event.stop();
    }

    /**
     * Returns the bundles for the given locales. The default implementation 
     * looks up the available bundles for the locales using the
     * package name plus "l10n" as base name. Note that the bundle returned
     * for a given locale may be the fallback bundle.
     *
     * @param toGet the locales to get bundles for
     * @return the map with locales and bundles
     */
    protected Map<Locale, ResourceBundle> l10nBundles(Set<Locale> toGet) {
        Map<Locale, ResourceBundle> result = new HashMap<>();
        for (Locale locale : toGet) {
            ResourceBundle bundle = l10nBundles.get(locale);
            if (bundle == null) {
                bundle = ResourceBundle.getBundle(
                    getClass().getPackage().getName() + ".l10n", locale,
                    getClass().getClassLoader(),
                    ResourceBundle.Control.getNoFallbackControl(
                        ResourceBundle.Control.FORMAT_DEFAULT));
                l10nBundles.put(locale, bundle);
            }
            result.put(locale, bundle);
        }
        return Collections.unmodifiableMap(result);
    }

    protected Map<Locale, String> displayNames(Set<Locale> locales,
            String key) {
        Map<Locale, String> result = new HashMap<>();
        Map<Locale, ResourceBundle> bundles = l10nBundles(locales);
        for (Map.Entry<Locale, ResourceBundle> entry : bundles.entrySet()) {
            result.put(entry.getKey(), entry.getValue().getString(key));
        }
        return result;
    }

    /**
     * Provides a resource bundle for localization.
     * The default implementation looks up a bundle using the
     * package name plus "l10n" as base name.
     * 
     * @return the resource bundle
     */
    protected ResourceBundle resourceBundle(Locale locale) {
        return ResourceBundle.getBundle(
            getClass().getPackage().getName() + ".l10n", locale,
            getClass().getClassLoader(),
            ResourceBundle.Control.getNoFallbackControl(
                ResourceBundle.Control.FORMAT_DEFAULT));
    }

    /**
     * Generates a new unique portlet id.
     * 
     * @return the portlet id
     */
    protected String generatePortletId() {
        return UUID.randomUUID().toString();
    }

    /**
     * Returns the tracked models and channels as unmodifiable map.
     * If sessions are not tracked, the method returns an empty map.
     * It is therefore always safe to invoke the method and use its
     * result.
     * 
     * If you need a particular session's portlet ids, you should
     * prefer {@link #portletIds(ConsoleSession)} over calling
     * this method with `get(portalSession)` appended.
     * 
     * @return the result
     */
    protected Map<ConsoleSession, Set<String>> portletIdsByPortalSession() {
        // Create copy to get a non-weak map.
        return Collections
            .unmodifiableMap(new HashMap<>(portletIdsByPortalSession));
    }

    /**
     * Returns the tracked sessions. This is effectively
     * `portletIdsByPortalSession().keySet()` converted to
     * an array. This representation is especially useful 
     * when the portal sessions are used as argument for 
     * {@link #fire(Event, Channel...)}.
     *
     * @return the portal sessions
     */
    protected ConsoleSession[] trackedSessions() {
        Set<ConsoleSession> sessions = new HashSet<>(
            portletIdsByPortalSession.keySet());
        return sessions.toArray(new ConsoleSession[0]);
    }

    /**
     * Returns the set of portlet ids associated with the portal session
     * as an unmodifiable {@link Set}. If sessions aren't tracked, or no
     * portlets have registered yet, an empty set is returned. The method 
     * can therefore always be called and always returns a usable result.
     * 
     * @param portalSession the portal session
     * @return the set
     */
    protected Set<String> portletIds(ConsoleSession portalSession) {
        return Collections.unmodifiableSet(
            portletIdsByPortalSession.getOrDefault(
                portalSession, Collections.emptySet()));
    }

    /**
     * Track the given portlet from the given session. This is invoked by
     * {@link #onAddPortletRequest(AddComponentRequest, ConsoleSession)} and
     * needs only be used if {@link #onAddPortletRequest} is overridden.
     *
     * @param portalSession the portal session
     * @param portletId the portlet id
     */
    protected void trackPortlet(ConsoleSession portalSession,
            String portletId) {
        portletIdsByPortalSession.computeIfAbsent(portalSession,
            newKey -> ConcurrentHashMap.newKeySet()).add(portletId);
        updateRefresh();
    }

    /**
     * Puts the given portlet state in the session using the 
     * {@link #type()} and the given portlet id as keys.
     * 
     * @param session the session to use
     * @param portletId the portlet id
     * @param portletState the portlet state
     * @return the portlet state
     */
    @SuppressWarnings({ "unchecked", "PMD.AvoidDuplicateLiterals" })
    protected Serializable putInSession(Session session, String portletId,
            Serializable portletState) {
        ((Map<Serializable,
                Map<Serializable, Map<String, Serializable>>>) (Map<
                        Serializable, ?>) session)
                            .computeIfAbsent(AbstractComponent.class,
                                newKey -> new ConcurrentHashMap<>())
                            .computeIfAbsent(type(),
                                newKey -> new ConcurrentHashMap<>())
                            .put(portletId, portletState);
        return portletState;
    }

    /**
     * Puts the given portlet instance state in the browser
     * session associated with the channel, using  
     * {@link #type()} and the portlet id from the model.
     *
     * @param session the session to use
     * @param portletModel the portlet model
     * @return the portlet model
     */
    protected <T extends PortletBaseModel> T putInSession(
            Session session, T portletModel) {
        putInSession(session, portletModel.getPortletId(), portletModel);
        return portletModel;
    }

    /**
     * Returns the portlet state of this portlet's type with the given id
     * from the session.
     * 
     * @param session the session to use
     * @param portletId the portlet id
     * @param type the state's type
     * @return the portlet state
     */
    @SuppressWarnings("unchecked")
    protected Optional<S> stateFromSession(Session session, String portletId) {
        return Optional.ofNullable(
            ((Map<Serializable,
                    Map<Serializable, Map<String, S>>>) (Map<Serializable,
                            ?>) session)
                                .computeIfAbsent(AbstractComponent.class,
                                    newKey -> new HashMap<>())
                                .computeIfAbsent(type(),
                                    newKey -> new HashMap<>())
                                .get(portletId));
    }

    /**
     * Returns all portlet states of this portlet's type from the
     * session.
     * 
     * @param channel the channel, used to access the session
     * @param type the states' type
     * @return the states
     */
    @SuppressWarnings("unchecked")
    protected Collection<S> statesFromSession(IOSubchannel channel) {
        return channel.associated(Session.class)
            .map(session -> ((Map<Serializable,
                    Map<Serializable, Map<String, S>>>) (Map<Serializable,
                            ?>) session)
                                .computeIfAbsent(AbstractComponent.class,
                                    newKey -> new HashMap<>())
                                .computeIfAbsent(type(),
                                    newKey -> new HashMap<>())
                                .values())
            .orElseThrow(
                () -> new IllegalStateException("Session is missing."));
    }

    /**
     * Removes the portlet state of the portlet with the given id
     * from the session. 
     * 
     * @param session the session to use
     * @param portletId the portlet id
     * @return the removed state if state existed
     */
    @SuppressWarnings("unchecked")
    protected Optional<S> removeState(Session session, String portletId) {
        S state = ((Map<Serializable,
                Map<Serializable, Map<String, S>>>) (Map<Serializable,
                        ?>) session)
                            .computeIfAbsent(AbstractComponent.class,
                                newKey -> new HashMap<>())
                            .computeIfAbsent(type(), newKey -> new HashMap<>())
                            .remove(portletId);
        return Optional.ofNullable(state);
    }

    /**
     * Checks if the request applies to this component. If so, stops the event,
     * and calls {@link #doAddPortlet}. 
     *
     * @param event the event
     * @param portalSession the channel
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings({ "PMD.SignatureDeclareThrowsException",
        "PMD.AvoidDuplicateLiterals" })
    public final void onAddPortletRequest(AddComponentRequest event,
            ConsoleSession portalSession) throws Exception {
        if (!event.portletType().equals(type())) {
            return;
        }
        event.stop();
        String portletId = doAddPortlet(event, portalSession);
        event.setResult(portletId);
        trackPortlet(portalSession, portletId);
    }

    /**
     * Called by {@link #onAddPortletRequest} to complete adding the portlet.
     * If the portlet has associated state, the implementation should
     * call {@link #putInSession(Session, String, Serializable)} to create
     * the state and put it in the session.
     * 
     * @param event the event
     * @param portalSession the channel
     * @return the id of the created portlet
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected abstract String doAddPortlet(AddComponentRequest event,
            ConsoleSession portalSession) throws Exception;

    /**
     * Checks if the request applies to this component. If so, stops 
     * the event, removes the portlet state from the browser session
     * and calls {@link #doDeletePortlet} with the state.
     * 
     * If the association of {@link ConsoleSession}s and portlet ids
     * is tracked for this portlet, any existing association is
     * also removed.
     *
     * @param event the event
     * @param portalSession the portal session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onDeletePortletRequest(DeleteComponentRequest event,
            ConsoleSession portalSession) throws Exception {
        Optional<S> optPortletState = stateFromSession(
            portalSession.browserSession(), event.portletId());
        if (!optPortletState.isPresent()) {
            return;
        }
        String portletId = event.portletId();
        removeState(portalSession.browserSession(), portletId);
        for (Iterator<ConsoleSession> psi = portletIdsByPortalSession
            .keySet().iterator(); psi.hasNext();) {
            Set<String> idSet = portletIdsByPortalSession.get(psi.next());
            idSet.remove(portletId);
            if (idSet.isEmpty()) {
                psi.remove();
            }
        }
        updateRefresh();
        event.stop();
        doDeletePortlet(event, portalSession, event.portletId(),
            optPortletState.get());
    }

    /**
     * Called by {@link #onDeletePortletRequest} to complete deleting
     * the portlet. If the portlet component wants to veto the
     * deletion of the portlet, it puts the state information back in
     * the session with 
     * {@link #putInSession(Session, String, Serializable)} and does
     * not fire the {@link DeleteComponent} event.
     * 
     * @param event the event
     * @param channel the channel
     * @param portletId the portlet id
     * @param portletState the portlet state
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected abstract void doDeletePortlet(DeleteComponentRequest event,
            ConsoleSession channel, String portletId, S portletState)
            throws Exception;

    /**
     * Checks if the request applies to this component by calling
     * {@link #stateFromSession(Session, String, Class)}. If a model
     * is found, sets the event's result to `true`, stops the event, and 
     * calls {@link #doRenderPortlet} with the state information. 
     * 
     * Some portlets that do not persist their models between sessions
     * (e.g. because the model only references data maintained elsewhere)
     * should override {@link #stateFromSession(Session, String, Class)}
     * in such a way that it creates the requested model if it doesn't 
     * exist yet.
     *
     * @param event the event
     * @param portalSession the portal session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onRenderPortlet(RenderComponentRequest event,
            ConsoleSession portalSession) throws Exception {
        Optional<S> optPortletState = stateFromSession(
            portalSession.browserSession(), event.portletId());
        if (!optPortletState.isPresent()) {
            return;
        }
        event.setResult(true);
        event.stop();
        doRenderPortlet(
            event, portalSession, event.portletId(), optPortletState.get());
        trackPortlet(portalSession, event.portletId());
    }

    /**
     * Called by {@link #onRenderPortlet} to complete rendering
     * the portlet.
     * 
     * @param event the event
     * @param channel the channel
     * @param portletId the portlet id
     * @param portletState the portletState
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected abstract void doRenderPortlet(RenderComponentRequest event,
            ConsoleSession channel, String portletId, S portletState)
            throws Exception;

    /**
     * Invokes {@link #doSetLocale(SetLocale, ConsoleSession, String)}
     * for each portlet in the portal session.
     * 
     * If the vent has the reload flag set, does nothing.
     * 
     * The default implementation fires a 
     *
     * @param event the event
     * @param portalSession the portal session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public void onSetLocale(SetLocale event, ConsoleSession portalSession)
            throws Exception {
        if (event.reload()) {
            return;
        }
        for (String portletId : portletIds(portalSession)) {
            if (!doSetLocale(event, portalSession, portletId)) {
                event.forceReload();
                break;
            }
        }
    }

    /**
     * Called by {@link #onSetLocale(SetLocale, ConsoleSession)} for
     * each portlet in the portal session. Derived classes must send
     * events for updating the representation to match the new locale.
     * 
     * If the method returns `false` this indicates that the representation 
     * cannot be updated without reloading the portal page.
     * 
     * The default implementation fires a {@link RenderComponentRequest}
     * with modes {@link RenderMode#Preview} and {@link RenderMode#View},
     * thus updating all possible representations. (Assuming that "Edit"
     * and "Help" modes are represented with modal dialogs and therefore
     * locale changes aren't possible while these are open.) 
     *
     * @param event the event
     * @param channel the channel
     * @param portletId the portlet id
     * @return true, if the locale could be changed
     * @throws Exception the exception
     */
    protected boolean doSetLocale(SetLocale event, ConsoleSession channel,
            String portletId) throws Exception {
        fire(new RenderComponentRequest(event.renderSupport(), portletId,
            RenderMode.asSet(RenderMode.Preview, RenderMode.View)),
            channel);
        return true;
    }

    /**
     * Checks if the request applies to this component by calling
     * {@link #stateFromSession(Session, String, Class)}. If a model
     * is found, calls {@link #doNotifyPortletModel} with the state 
     * information. 
     *
     * @param event the event
     * @param channel the channel
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onNotifyPortletModel(NotifyComponentModel event,
            ConsoleSession channel) throws Exception {
        Optional<S> optPortletState
            = stateFromSession(channel.browserSession(), event.portletId());
        if (!optPortletState.isPresent()) {
            return;
        }
        doNotifyPortletModel(event, channel, optPortletState.get());
    }

    /**
     * Called by {@link #onNotifyPortletModel} to complete handling
     * the notification. The default implementation does nothing.
     * 
     * @param event the event
     * @param channel the channel
     * @param portletState the portletState
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected void doNotifyPortletModel(NotifyComponentModel event,
            ConsoleSession channel, S portletState) throws Exception {
        // Default is to do nothing.
    }

    /**
     * Removes the {@link ConsoleSession} from the set of tracked sessions.
     * If derived portlets need to perform extra actions when a
     * portalSession is closed, they have to override 
     * {@link #afterOnClosed(Closed, ConsoleSession)}.
     * 
     * @param event the closed event
     * @param portalSession the portal session
     */
    @Handler
    public final void onClosed(Closed event, ConsoleSession portalSession) {
        portletIdsByPortalSession.remove(portalSession);
        updateRefresh();
        afterOnClosed(event, portalSession);
    }

    /**
     * Invoked by {@link #onClosed(Closed, ConsoleSession)} after
     * the portal session has been removed from the set of
     * tracked sessions. The default implementation does
     * nothing.
     * 
     * @param event the closed event
     * @param portalSession the portal session
     */
    protected void afterOnClosed(Closed event, ConsoleSession portalSession) {
        // Default is to do nothing.
    }

    /**
     * Defines the portlet model following the JavaBean conventions.
     * 
     * ConsoleComponent models should follow these conventions because
     * many template engines rely on them and to support serialization
     * to portable formats. 
     */
    @SuppressWarnings("serial")
    public static class PortletBaseModel implements Serializable {

        protected String portletId;

        /**
         * Creates a new model with the given type and id.
         * 
         * @param portletId the portlet id
         */
        @ConstructorProperties({ "portletId" })
        public PortletBaseModel(String portletId) {
            this.portletId = portletId;
        }

        /**
         * Returns the portlet id.
         * 
         * @return the portlet id
         */
        public String getPortletId() {
            return portletId;
        }

        /**
         * Hash code.
         *
         * @return the int
         */
        /*
         * (non-Javadoc)
         * 
         * @see java.lang.Object#hashCode()
         */
        @Override
        @SuppressWarnings("PMD.DataflowAnomalyAnalysis")
        public int hashCode() {
            @SuppressWarnings("PMD.AvoidFinalLocalVariable")
            final int prime = 31;
            int result = 1;
            result = prime * result
                + ((portletId == null) ? 0 : portletId.hashCode());
            return result;
        }

        /**
         * Two objects are equal if they have equal portlet ids.
         * 
         * @param obj the other object
         * @return the result
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            PortletBaseModel other = (PortletBaseModel) obj;
            if (portletId == null) {
                if (other.portletId != null) {
                    return false;
                }
            } else if (!portletId.equals(other.portletId)) {
                return false;
            }
            return true;
        }
    }

    /**
     * Send to the portal page for adding or updating a complete portlet
     * representation.
     */
    public class RenderPortletFromReader extends RenderComponent {

        private final Future<String> content;

        /**
         * Creates a new event.
         *
         * @param request the request
         * @param portletClass the portlet class
         * @param portletId the id of the portlet
         * @param contentReader the content reader
         */
        public RenderPortletFromReader(RenderComponentRequestBase<?> request,
                Class<?> portletClass, String portletId, Reader contentReader) {
            super(portletClass, portletId);
            // Start to prepare the content immediately and concurrently.
            content = request.processedBy().map(pby -> pby.executorService())
                .orElse(Components.defaultExecutorService()).submit(() -> {
                    StringWriter content = new StringWriter();
                    CharBuffer buffer = CharBuffer.allocate(8192);
                    try (Reader rdr = new BufferedReader(contentReader)) {
                        while (true) {
                            if (rdr.read(buffer) < 0) {
                                break;
                            }
                            buffer.flip();
                            content.append(buffer);
                            buffer.clear();
                        }
                    } catch (IOException e) {
                        throw new IllegalStateException(e);
                    }
                    return content.toString();
                });

        }

        /**
         * Content.
         *
         * @return the future
         */
        @Override
        public Future<String> content() {
            return content;
        }
    }
}
